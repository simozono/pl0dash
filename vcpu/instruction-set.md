汎用レジスタはA,B,Cの3個
プログラムカウンタ(PC)
スタックポインタ(SP)
フレームポインタ(FP)

メモリ構成
メモリのアドレスはワード毎にふってあるとする。
1行のアセンブリ言語は1ワードに入る
メモリの番地は1番地から1000番地まで
プログラムコード領域は、800番地まで。
ヒープ領域(大域変数領域)は、801番地から。
スタック領域は、1000番地から下がる方向で。

演算命令の基本は 「A 演算子 B」の結果がCに入る。

メモリからレジスタへの代入はLOAD
レジスタからメモリへの代入はSTORE

LOAD reg, 数字
regは A,B,Cのいずれか。数字をregに代入

LOAD reg, #(数字)
数字番地のメモリ内容をregに代入

STORE reg, #(数字)
regの内容をメモリの数字番地に代入

STORE reg1, #(reg2)
reg2の内容がメモリの数字番地を表しているとし、そこにreg1の内容を代入する

演算子関係


二項演算子
PLUS
レジスタAの内容とレジスタBの内容を足して、結果をレジスタCに格納。つまりC=A+B

MINUS
C=A-B

MULTI
C=A*B

DIV
C=A/B

比較演算子
CMPODD
レジスタAが奇数ならば、レジスタCが1になる、それ以外はレジスタCは0

CMPEQ
レジスタAとレジスタBが同じ値ならば、レジスタCが1になる、それ以外はレジスタCは0

CMPNOTEQ
レジスタAとレジスタBが違う値ならば、レジスタCが1になる、それ以外はレジスタCは0

CMPLT
レジスタA<レジスタBが真ならば、レジスタCが1になる、それ以外はレジスタCは0

CMPGT
レジスタA>レジスタBが真ならば、レジスタCが1になる、それ以外はレジスタCは0

CMPLE
レジスタA<=レジスタBが真ならば、レジスタCが1になる、それ以外はレジスタCは0

CMPGE
レジスタA>=レジスタBが真ならば、レジスタCが1になる、それ以外はレジスタCは0

ジャンプ関係

JMP address
無条件ジャンプ

JPC address
Cが0(偽)ならば、ジャンプする

### CALL
現在のPCの値(CALL の行を指しているはず)の次の値をスタックに積んで、
引数行へジャンプ, SPは移動する(PC値が入っているところを指しているはず)

呼び出された側の処理
現在のFPの値をスタックに積む
SPの値をFPにセットする
:wq

### RET 

スタック操作関連
PUSH reg
reg の内容をスタックに積む(正確には SP-1->SPの後,SP位置にregを代入)

POP reg
スタックから1つ取り出して、reg に入れるむ(正確にはSP位置の内容をregに代入、その後、SP+1->SP)


表示関連
PRINT reg
PRINTLN
